/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/public/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* no static exports found */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(module, exports) {

eval("var $mineSweeper = $('#myMineSweeper');\nvar height = 0;\nvar width = 0;\nvar mines = 0;\nvar array = [];\nvar flagCounter = 0;\nvar timerAndHighscore = 1;\nvar startTimer;\nvar topTenScore = [];\nvar database = firebase.database();\n\nfunction AddHighScore(number, name) {\n    var hsKey = database.ref().child('highscore').push().key;\n    var highScore = { score: number, username: name };\n    var updates = {};\n    updates['/highscore/' + width + height + '/' + hsKey] = highScore;\n    database.ref().update(updates);\n    ResetHighScore();\n}\n\nfunction UpdateCounterText() {\n    var nextCounter = array.reduce((p, c) => p - c.filter(o => o.flag).length, mines);\n    $('#counterText').text(nextCounter);\n    flagCounter = nextCounter;\n};\n\nfunction StartGame() {\n    if (width === 9 && height === 9) {\n        mines = 10;\n    } else if (width === 16 && height === 16) {\n        mines = 40;\n    } else if (width === 30 && height === 16) {\n        mines = 99;\n    }\n\n    for (var i = 0; i < height; i++) {\n        array[i] = [];\n        for (var j = 0; j < width; j++) {\n            array[i][j] = {\n                number: 0,\n                open: false,\n                mine: false,\n                flag: false,\n                ask: false\n            };\n        }\n    }\n    for (var i = 0; i < mines; i++) {\n        AddRandomMine();\n    }\n\n    function AddRandomMine() {\n        var loop = true;\n        while (loop) {\n            var column = Math.floor(Math.random() * width);\n            var row = Math.floor(Math.random() * height);\n\n            if (!array[row][column].mine) {\n                array[row][column].mine = true;\n                loop = false;\n            }\n        }\n    };\n\n    AddNumbers();\n    function AddNumbers() {\n        for (var i = 0; i < array.length; i++) {\n            for (var j = 0; j < array[i].length; j++) {\n                if (!array[i][j].mine) {\n                    var surroundingCells = GetSurroundingMines(array, i, j);\n                    array[i][j].number = surroundingCells.length;\n                }\n            }\n        }\n    };\n\n    function GetSurroundingMines(array, i, j) {\n        var simonCells = [[i + 1, j], [i + 1, j + 1], [i + 1, j - 1], [i - 1, j], [i - 1, j - 1], [i - 1, j + 1], [i, j + 1], [i, j - 1]];\n\n        var validCells = simonCells.filter(function (cell) {\n            var i = cell[0];\n            var j = cell[1];\n            return i >= 0 && i < array.length && j >= 0 && j < array[0].length;\n        });\n        var realCells = validCells.map(function (cell) {\n            var i = cell[0];\n            var j = cell[1];\n            return array[i][j];\n        });\n        var numberOfMines = realCells.filter(function (array) {\n            return array.mine;\n        });\n        return numberOfMines;\n    };\n    //Reset counter and button picture\n    Reset();\n    render();\n    function render() {\n        $mineSweeper.empty();\n        for (var i = 0; i < array.length; i++) {\n            var $myRow = $('<div/>', { class: 'row' });\n            $mineSweeper.append($myRow);\n            for (var j = 0; j < array[i].length; j++) {\n                var selectedCell = array[i][j];\n                var text = selectedCell.mine ? ' ' : selectedCell.number > 0 ? selectedCell.number : ' ';\n                $myRow.append($('<button/>', {\n                    type: 'button', 'data-i': i, 'data-j': j,\n                    text: selectedCell.open ? text : ' ',\n                    class: selectedCell.open && selectedCell.mine ? 'openmineCell' : selectedCell.open ? 'opencell' : selectedCell.flag ? 'flagCell' : selectedCell.ask ? 'askCell' : 'cell'\n                }));\n            }\n        }\n    };\n\n    function OpenSurroundingCells(i, j) {\n        var surroundingCells = [[i + 1, j], [i + 1, j + 1], [i + 1, j - 1], [i - 1, j], [i - 1, j - 1], [i - 1, j + 1], [i, j + 1], [i, j - 1]];\n        var validCells = surroundingCells.filter(cell => {\n            var i = cell[0];\n            var j = cell[1];\n            return i >= 0 && i < array.length && j >= 0 && j < array[0].length;\n        });\n        var cellsForRecursion = validCells.filter(cell => {\n            i = cell[0];\n            j = cell[1];\n            return array[i][j].open == false && array[i][j].number == 0;\n        });\n        validCells.forEach(cell => {\n            i = cell[0];\n            j = cell[1];\n            array[i][j].open = true;\n            array[i][j].flag = false;\n            array[i][j].ask = false;\n        });\n        return cellsForRecursion;\n    };\n\n    function OpenSurroundingNonFlaggedCells(i, j) {\n        var surroundingCells = [[i + 1, j], [i + 1, j + 1], [i + 1, j - 1], [i - 1, j], [i - 1, j - 1], [i - 1, j + 1], [i, j + 1], [i, j - 1]];\n        var validCells = surroundingCells.filter(cell => {\n            let k = cell[0];\n            let l = cell[1];\n            return k >= 0 && k < array.length && l >= 0 && l < array[0].length;\n        });\n        var flagCells = validCells.filter(cell => {\n            let k = cell[0];\n            let l = cell[1];\n            return array[k][l].flag;\n        });\n        if (flagCells.length == array[i][j].number) {\n            validCells.forEach(cell => {\n                let k = cell[0];\n                let l = cell[1];\n                if (!array[k][l].flag) {\n                    if (array[k][l].mine) {\n                        array.forEach(r => r.forEach(cell => cell.open = true));\n                        $('.playAgain').attr('class', 'userLost');\n                        clearInterval(startTimer);\n                    };\n                    if (array[k][l].number == 0 && !array[k][l].mine) {\n                        ClickedOnZero(k, l);\n                    };\n                    array[k][l].open = true;\n                    array[k][l].flag = false;\n                    array[k][l].ask = false;\n                }\n            });\n        }\n        if (UserWon(i, j)) clearInterval(startTimer);\n        render();\n    };\n\n    $(document).on('dblclick', '.opencell', function (e) {\n        e.stopImmediatePropagation();\n        var $cell = $(this);\n        var i = $cell.data('i');\n        var j = $cell.data('j');\n        OpenSurroundingNonFlaggedCells(i, j);\n    });\n\n    $(document).on('contextmenu', '.flagCell, .cell, .askCell', function (event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        var $cell = $(this);\n        const setCellClass = n => $cell.attr('class', n);\n\n        var i = $cell.data('i');\n        var j = $cell.data('j');\n\n        switch ($cell.attr('class')) {\n            case 'cell':\n                if (flagCounter >= 1) {\n                    array[i][j].flag = true;\n                    setCellClass('flagCell');\n                    break;\n                } else {\n                    return;\n                }\n            case 'flagCell':\n                array[i][j].flag = false;\n                array[i][j].ask = true;\n                setCellClass('askCell');\n                break;\n            case 'askCell':\n                array[i][j].ask = false;\n                setCellClass('cell');\n                break;\n            default:\n                break;\n        };\n        UpdateCounterText(mines);\n    });\n\n    $(document).on('click', '.cell', function (event) {\n        event.stopImmediatePropagation();\n        var $cell = $(this);\n        var i = $cell.data('i');\n        var j = $cell.data('j');\n\n        if (array[i][j].number != 0) {\n            array[i][j].open = true;\n        } else if (array[i][j].number == 0 && !array[i][j].mine) {\n            ClickedOnZero(i, j);\n        } else if (array[i][j].mine) {\n            array.forEach(r => r.forEach(cell => cell.open = true));\n            $('.playAgain').attr('class', 'userLost');\n            clearInterval(startTimer);\n        };\n\n        if (UserWon(i, j)) {\n            clearInterval(startTimer);\n        }\n\n        UpdateCounterText(mines);\n        render();\n    });\n\n    function ClickedOnZero(i, j) {\n        array[i][j].open = true;\n        var allCellsToCheck = OpenSurroundingCells(i, j);\n        var loopingLength = allCellsToCheck;\n        for (var k = 0; k < loopingLength.length; k++) {\n            i = allCellsToCheck[k][0];\n            j = allCellsToCheck[k][1];\n            var returnedCells = OpenSurroundingCells(i, j);\n            if (returnedCells.length > 0) {\n                for (var l = 0; l < returnedCells.length; l++) {\n                    loopingLength.push(returnedCells[l]);\n                }\n            }\n        }\n    }\n\n    function UserWon(i, j) {\n        var closedCells = array.reduce((p, c) => c.filter(o => !o.open).length + p, 0);\n\n        if (closedCells == mines && array[i][j].mine == false) {\n            array[i][j].open = true;\n            $('.playAgain').attr('class', 'userWon');\n            array.forEach(r => r.forEach(cell => cell.open = true));\n            render();\n            AskForHighScoreSubmit();\n            return true;\n        } else return false;\n    }\n}\n\nfunction SetSize(w, h) {\n    width = parseInt(w);\n    height = parseInt(h);\n    var mines = Math.round(width * height / 8) + 1;\n    $('#size').toggle();\n    $('#game').toggle();\n    ResetHighScore();\n    StartGame();\n}\n\nfunction SetCustomSize(w, h) {\n    height = $('#height').val();\n    height = parseInt(height);\n    width = $('#width').val();\n    width = parseInt(width);\n\n    if (height >= 2 && width >= 2 && height <= 50 && width <= 50) {\n        var mines = Math.round(width * height / 8) + 1;\n        $('#size').toggle();\n        $('#game').toggle();\n        ResetHighScore();\n        StartGame();\n    } else {\n        $('#chooseSize').html('<p style=\"color: red;\">Too many ingredients<p/>');\n        return;\n    }\n}\n\nfunction AskForHighScoreSubmit() {\n    if (topTenScore.length >= 10) {\n        if (topTenScore[9].score > timerAndHighscore) {\n            if (confirm('Top ten! Submit highscore?')) {\n                var name = prompt('Choose name (max 10 characters)');\n                while (true) {\n                    if (name.length <= 10) {\n                        AddHighScore(timerAndHighscore, name);\n                        break;\n                    } else {\n                        name = prompt('Max 10 characters');\n                    }\n                }\n            }\n        } else {\n            alert('Too bad!');\n        }\n    } else {\n        if (confirm('Top ten! Submit highscore?')) {\n            var name = prompt('Choose name (max 10 characters)');\n            while (true) {\n                if (name.length <= 10) {\n                    AddHighScore(timerAndHighscore, name);\n                    break;\n                } else {\n                    name = prompt('Max 10 characters');\n                }\n            }\n        }\n    }\n}\n\nfunction Reset() {\n    UpdateCounterText();\n    $('#playAgain').attr('class', 'playAgain');\n    try {\n        clearInterval(startTimer);\n    } catch (error) {}\n    timerAndHighscore = 1;\n    $('#timer').text(timerAndHighscore);\n    startTimer = setInterval(() => {\n        timerAndHighscore++;$('#timer').text(timerAndHighscore);\n    }, 1000);\n}\n\nfunction ResetHighScore() {\n    $('#highScoreText').text('Lowscore ' + width + ' x ' + height);\n    $('#hsBody').empty();\n    topTenScore = [];\n    database.ref('/highscore/' + width + height + '/').once('value').then(function (snapshot) {\n        let obj = snapshot.val();\n        for (var key in obj) {\n            topTenScore.push({ username: obj[key].username, score: obj[key].score });\n        }\n        topTenScore.sort((a, b) => a.score - b.score);\n        topTenScore.forEach(c => {\n            var newTr = $('<tr/>');\n            newTr.append($('<td/>', { text: c.username }));\n            newTr.append($('<td/>', { text: c.score, class: 'scoreTd' }));\n            $('#hsBody').append(newTr);\n        });\n    });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJG1pbmVTd2VlcGVyID0gJCgnI215TWluZVN3ZWVwZXInKTtcbnZhciBoZWlnaHQgPSAwO1xudmFyIHdpZHRoID0gMDtcbnZhciBtaW5lcyA9IDA7XG52YXIgYXJyYXkgPSBbXTtcbnZhciBmbGFnQ291bnRlciA9IDA7XG52YXIgdGltZXJBbmRIaWdoc2NvcmUgPSAxO1xudmFyIHN0YXJ0VGltZXI7XG52YXIgdG9wVGVuU2NvcmUgPSBbXTtcbnZhciBkYXRhYmFzZSA9IGZpcmViYXNlLmRhdGFiYXNlKCk7XG5cblxuZnVuY3Rpb24gQWRkSGlnaFNjb3JlKG51bWJlciwgbmFtZSkge1xuICAgIHZhciBoc0tleSA9IGRhdGFiYXNlLnJlZigpLmNoaWxkKCdoaWdoc2NvcmUnKS5wdXNoKCkua2V5O1xuICAgIHZhciBoaWdoU2NvcmUgPSB7c2NvcmU6IG51bWJlciwgdXNlcm5hbWU6IG5hbWV9O1xuICAgIHZhciB1cGRhdGVzID0ge307XG4gICAgdXBkYXRlc1snL2hpZ2hzY29yZS8nICsgd2lkdGggKyBoZWlnaHQgKyAnLycgKyBoc0tleV0gPSBoaWdoU2NvcmU7XG4gICAgZGF0YWJhc2UucmVmKCkudXBkYXRlKHVwZGF0ZXMpXG4gICAgUmVzZXRIaWdoU2NvcmUoKTtcbn1cblxuZnVuY3Rpb24gVXBkYXRlQ291bnRlclRleHQoKXtcbiAgICB2YXIgbmV4dENvdW50ZXIgPSBhcnJheVxuICAgIC5yZWR1Y2UoKHAsIGMpID0+IHAgLSBjLmZpbHRlcihvID0+IG8uZmxhZykubGVuZ3RoLCBtaW5lcyk7XG4gICAgJCgnI2NvdW50ZXJUZXh0JykudGV4dChuZXh0Q291bnRlcilcbiAgICBmbGFnQ291bnRlciA9IG5leHRDb3VudGVyO1xufTtcblxuZnVuY3Rpb24gU3RhcnRHYW1lKCkge1xuICAgIGlmKHdpZHRoID09PSA5ICYmIGhlaWdodCA9PT0gOSl7XG4gICAgICAgIG1pbmVzID0gMTA7XG4gICAgfVxuICAgIGVsc2UgaWYod2lkdGggPT09IDE2ICYmIGhlaWdodCA9PT0gMTYpe1xuICAgICAgICBtaW5lcyA9IDQwO1xuICAgIH1cbiAgICBlbHNlIGlmKHdpZHRoID09PSAzMCAmJiBoZWlnaHQgPT09IDE2KXtcbiAgICAgICAgbWluZXMgPSA5OTtcbiAgICB9XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgICAgIGFycmF5W2ldW2pdID0ge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMCxcbiAgICAgICAgICAgICAgICBvcGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtaW5lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmbGFnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc2s6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluZXM7IGkrKykge1xuICAgICAgICBBZGRSYW5kb21NaW5lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQWRkUmFuZG9tTWluZSgpIHtcbiAgICAgICAgdmFyIGxvb3AgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobG9vcCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHdpZHRoKVxuICAgICAgICAgICAgdmFyIHJvdyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGhlaWdodClcblxuICAgICAgICAgICAgaWYgKCFhcnJheVtyb3ddW2NvbHVtbl0ubWluZSkge1xuICAgICAgICAgICAgICAgIGFycmF5W3Jvd11bY29sdW1uXS5taW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQWRkTnVtYmVycygpO1xuICAgIGZ1bmN0aW9uIEFkZE51bWJlcnMoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyYXlbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycmF5W2ldW2pdLm1pbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1cnJvdW5kaW5nQ2VsbHMgPSBHZXRTdXJyb3VuZGluZ01pbmVzKGFycmF5LCBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbaV1bal0ubnVtYmVyID0gc3Vycm91bmRpbmdDZWxscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEdldFN1cnJvdW5kaW5nTWluZXMoYXJyYXksIGksIGopIHtcbiAgICAgICAgdmFyIHNpbW9uQ2VsbHMgPSBbW2kgKyAxLCBqXSwgW2kgKyAxLCBqICsgMV0sIFtpICsgMSwgaiAtIDFdLCBbaSAtIDEsIGpdLCBbaSAtIDEsIGogLSAxXSwgW2kgLSAxLCBqICsgMV0sIFtpLCBqICsgMV0sIFtpLCBqIC0gMV1dO1xuXG4gICAgICAgIHZhciB2YWxpZENlbGxzID0gc2ltb25DZWxscy5maWx0ZXIoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgIHZhciBpID0gY2VsbFswXVxuICAgICAgICAgICAgdmFyIGogPSBjZWxsWzFdXG4gICAgICAgICAgICByZXR1cm4gaSA+PSAwICYmIGkgPCBhcnJheS5sZW5ndGggJiYgaiA+PSAwICYmIGogPCBhcnJheVswXS5sZW5ndGhcbiAgICAgICAgfSlcbiAgICAgICAgdmFyIHJlYWxDZWxscyA9IHZhbGlkQ2VsbHMubWFwKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGNlbGxbMF1cbiAgICAgICAgICAgIHZhciBqID0gY2VsbFsxXVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5W2ldW2pdXG4gICAgICAgIH0pXG4gICAgICAgIHZhciBudW1iZXJPZk1pbmVzID0gcmVhbENlbGxzLmZpbHRlcihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5taW5lO1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gbnVtYmVyT2ZNaW5lcztcbiAgICB9O1xuICAgIC8vUmVzZXQgY291bnRlciBhbmQgYnV0dG9uIHBpY3R1cmVcbiAgICBSZXNldCgpO1xuICAgIHJlbmRlcigpO1xuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgJG1pbmVTd2VlcGVyLmVtcHR5KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAkbXlSb3cgPSAkKCc8ZGl2Lz4nLCB7IGNsYXNzOiAncm93JyB9KVxuICAgICAgICAgICAgJG1pbmVTd2VlcGVyLmFwcGVuZCgkbXlSb3cpXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkQ2VsbCA9IGFycmF5W2ldW2pdXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzZWxlY3RlZENlbGwubWluZSA/ICcgJyA6IHNlbGVjdGVkQ2VsbC5udW1iZXIgPiAwID8gc2VsZWN0ZWRDZWxsLm51bWJlciA6ICcgJztcbiAgICAgICAgICAgICAgICAkbXlSb3cuYXBwZW5kKCQoJzxidXR0b24vPicsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2J1dHRvbicsICdkYXRhLWknOiBpLCAnZGF0YS1qJzogaixcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogc2VsZWN0ZWRDZWxsLm9wZW4gPyB0ZXh0IDogJyAnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczogc2VsZWN0ZWRDZWxsLm9wZW4gJiYgc2VsZWN0ZWRDZWxsLm1pbmUgPyAnb3Blbm1pbmVDZWxsJyA6IHNlbGVjdGVkQ2VsbC5vcGVuID8gJ29wZW5jZWxsJyA6IHNlbGVjdGVkQ2VsbC5mbGFnID8gJ2ZsYWdDZWxsJyA6IHNlbGVjdGVkQ2VsbC5hc2sgPyAnYXNrQ2VsbCcgOiAnY2VsbCdcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBPcGVuU3Vycm91bmRpbmdDZWxscyhpLCBqKSB7XG4gICAgICAgIHZhciBzdXJyb3VuZGluZ0NlbGxzID0gW1tpICsgMSwgal0sIFtpICsgMSwgaiArIDFdLCBbaSArIDEsIGogLSAxXSwgW2kgLSAxLCBqXSwgW2kgLSAxLCBqIC0gMV0sIFtpIC0gMSwgaiArIDFdLCBbaSwgaiArIDFdLCBbaSwgaiAtIDFdXTtcbiAgICAgICAgdmFyIHZhbGlkQ2VsbHMgPSBzdXJyb3VuZGluZ0NlbGxzLmZpbHRlcigoY2VsbCkgPT4ge1xuICAgICAgICAgICAgdmFyIGkgPSBjZWxsWzBdXG4gICAgICAgICAgICB2YXIgaiA9IGNlbGxbMV1cbiAgICAgICAgICAgIHJldHVybiBpID49IDAgJiYgaSA8IGFycmF5Lmxlbmd0aCAmJiBqID49IDAgJiYgaiA8IGFycmF5WzBdLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNlbGxzRm9yUmVjdXJzaW9uID0gdmFsaWRDZWxscy5maWx0ZXIoKGNlbGwpID0+IHtcbiAgICAgICAgICAgIGkgPSBjZWxsWzBdXG4gICAgICAgICAgICBqID0gY2VsbFsxXVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5W2ldW2pdLm9wZW4gPT0gZmFsc2UgJiYgYXJyYXlbaV1bal0ubnVtYmVyID09IDA7XG4gICAgICAgIH0pO1xuICAgICAgICB2YWxpZENlbGxzLmZvckVhY2goKGNlbGwpID0+IHtcbiAgICAgICAgICAgIGkgPSBjZWxsWzBdXG4gICAgICAgICAgICBqID0gY2VsbFsxXVxuICAgICAgICAgICAgYXJyYXlbaV1bal0ub3BlbiA9IHRydWU7XG4gICAgICAgICAgICBhcnJheVtpXVtqXS5mbGFnID0gZmFsc2U7XG4gICAgICAgICAgICBhcnJheVtpXVtqXS5hc2sgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjZWxsc0ZvclJlY3Vyc2lvbjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gT3BlblN1cnJvdW5kaW5nTm9uRmxhZ2dlZENlbGxzKGksIGopIHtcbiAgICAgICAgdmFyIHN1cnJvdW5kaW5nQ2VsbHMgPSBbW2kgKyAxLCBqXSwgW2kgKyAxLCBqICsgMV0sIFtpICsgMSwgaiAtIDFdLCBbaSAtIDEsIGpdLCBbaSAtIDEsIGogLSAxXSwgW2kgLSAxLCBqICsgMV0sIFtpLCBqICsgMV0sIFtpLCBqIC0gMV1dO1xuICAgICAgICB2YXIgdmFsaWRDZWxscyA9IHN1cnJvdW5kaW5nQ2VsbHMuZmlsdGVyKChjZWxsKSA9PiB7XG4gICAgICAgICAgICBsZXQgayA9IGNlbGxbMF1cbiAgICAgICAgICAgIGxldCBsID0gY2VsbFsxXVxuICAgICAgICAgICAgcmV0dXJuIGsgPj0gMCAmJiBrIDwgYXJyYXkubGVuZ3RoICYmIGwgPj0gMCAmJiBsIDwgYXJyYXlbMF0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZmxhZ0NlbGxzID0gdmFsaWRDZWxscy5maWx0ZXIoKGNlbGwpID0+IHtcbiAgICAgICAgICAgIGxldCBrID0gY2VsbFswXVxuICAgICAgICAgICAgbGV0IGwgPSBjZWxsWzFdXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlba11bbF0uZmxhZ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYoZmxhZ0NlbGxzLmxlbmd0aCA9PSBhcnJheVtpXVtqXS5udW1iZXIpe1xuICAgICAgICAgICAgdmFsaWRDZWxscy5mb3JFYWNoKChjZWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGsgPSBjZWxsWzBdO1xuICAgICAgICAgICAgICAgIGxldCBsID0gY2VsbFsxXTtcbiAgICAgICAgICAgICAgICBpZighYXJyYXlba11bbF0uZmxhZyl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJheVtrXVtsXS5taW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheS5mb3JFYWNoKHIgPT4gci5mb3JFYWNoKGNlbGwgPT4gY2VsbC5vcGVuID0gdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLnBsYXlBZ2FpbicpLmF0dHIoJ2NsYXNzJywgJ3VzZXJMb3N0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoc3RhcnRUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJheVtrXVtsXS5udW1iZXIgPT0gMCAmJiAhYXJyYXlba11bbF0ubWluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ2xpY2tlZE9uWmVybyhrLCBsKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlba11bbF0ub3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2tdW2xdLmZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlba11bbF0uYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBpZihVc2VyV29uKGksIGopKVxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzdGFydFRpbWVyKTtcbiAgICAgICAgcmVuZGVyKCk7XG4gICAgfTtcblxuICAgICQoZG9jdW1lbnQpLm9uKCdkYmxjbGljaycsICcub3BlbmNlbGwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB2YXIgJGNlbGwgPSAkKHRoaXMpO1xuICAgICAgICB2YXIgaSA9ICRjZWxsLmRhdGEoJ2knKTtcbiAgICAgICAgdmFyIGogPSAkY2VsbC5kYXRhKCdqJyk7XG4gICAgICAgIE9wZW5TdXJyb3VuZGluZ05vbkZsYWdnZWRDZWxscyhpLCBqKTtcbiAgICB9KTtcblxuICAgICQoZG9jdW1lbnQpLm9uKCdjb250ZXh0bWVudScsICcuZmxhZ0NlbGwsIC5jZWxsLCAuYXNrQ2VsbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdmFyICRjZWxsID0gJCh0aGlzKTtcbiAgICAgICAgY29uc3Qgc2V0Q2VsbENsYXNzID0gKG4pID0+ICRjZWxsLmF0dHIoJ2NsYXNzJywgbik7XG5cbiAgICAgICAgdmFyIGkgPSAkY2VsbC5kYXRhKCdpJyk7XG4gICAgICAgIHZhciBqID0gJGNlbGwuZGF0YSgnaicpO1xuICAgICAgICBcbiAgICAgICAgc3dpdGNoKCRjZWxsLmF0dHIoJ2NsYXNzJykpe1xuICAgICAgICAgICAgY2FzZSAnY2VsbCc6XG4gICAgICAgICAgICAgICAgaWYoZmxhZ0NvdW50ZXIgPj0gMSl7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2ldW2pdLmZsYWcgPSB0cnVlOyAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc2V0Q2VsbENsYXNzKCdmbGFnQ2VsbCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2ZsYWdDZWxsJzpcbiAgICAgICAgICAgICAgICBhcnJheVtpXVtqXS5mbGFnID0gZmFsc2U7ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYXJyYXlbaV1bal0uYXNrID0gdHJ1ZTsgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2V0Q2VsbENsYXNzKCdhc2tDZWxsJylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Fza0NlbGwnOlxuICAgICAgICAgICAgICAgIGFycmF5W2ldW2pdLmFzayA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2V0Q2VsbENsYXNzKCdjZWxsJylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH07XG4gICAgICAgIFVwZGF0ZUNvdW50ZXJUZXh0KG1pbmVzKTsgICAgICAgICAgXG4gICAgfSlcblxuICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcuY2VsbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdmFyICRjZWxsID0gJCh0aGlzKVxuICAgICAgICB2YXIgaSA9ICRjZWxsLmRhdGEoJ2knKTtcbiAgICAgICAgdmFyIGogPSAkY2VsbC5kYXRhKCdqJyk7XG5cbiAgICAgICAgaWYgKGFycmF5W2ldW2pdLm51bWJlciAhPSAwKSB7XG4gICAgICAgICAgICBhcnJheVtpXVtqXS5vcGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcnJheVtpXVtqXS5udW1iZXIgPT0gMCAmJiAhYXJyYXlbaV1bal0ubWluZSkge1xuICAgICAgICAgICAgQ2xpY2tlZE9uWmVybyhpLCBqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGFycmF5W2ldW2pdLm1pbmUpIHtcbiAgICAgICAgICAgIGFycmF5LmZvckVhY2gociA9PiByLmZvckVhY2goY2VsbCA9PiBjZWxsLm9wZW4gPSB0cnVlKSk7XG4gICAgICAgICAgICAkKCcucGxheUFnYWluJykuYXR0cignY2xhc3MnLCAndXNlckxvc3QnKVxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzdGFydFRpbWVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZihVc2VyV29uKGksIGopKXtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoc3RhcnRUaW1lcik7XG4gICAgICAgIH1cbiAgICAgICBcbiAgICAgICAgVXBkYXRlQ291bnRlclRleHQobWluZXMpO1xuICAgICAgICByZW5kZXIoKTtcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gQ2xpY2tlZE9uWmVybyhpLCBqKSB7XG4gICAgICAgIGFycmF5W2ldW2pdLm9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGFsbENlbGxzVG9DaGVjayA9IE9wZW5TdXJyb3VuZGluZ0NlbGxzKGksIGopO1xuICAgICAgICAgICAgdmFyIGxvb3BpbmdMZW5ndGggPSBhbGxDZWxsc1RvQ2hlY2s7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxvb3BpbmdMZW5ndGgubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpID0gYWxsQ2VsbHNUb0NoZWNrW2tdWzBdO1xuICAgICAgICAgICAgICAgIGogPSBhbGxDZWxsc1RvQ2hlY2tba11bMV07XG4gICAgICAgICAgICAgICAgdmFyIHJldHVybmVkQ2VsbHMgPSBPcGVuU3Vycm91bmRpbmdDZWxscyhpLCBqKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWRDZWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgcmV0dXJuZWRDZWxscy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcGluZ0xlbmd0aC5wdXNoKHJldHVybmVkQ2VsbHNbbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFVzZXJXb24oaSwgaikge1xuICAgICAgICB2YXIgY2xvc2VkQ2VsbHMgPSBhcnJheVxuICAgICAgICAucmVkdWNlKChwLCBjKSA9PiBjLmZpbHRlcihvID0+ICFvLm9wZW4pLmxlbmd0aCArIHAsIDApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNsb3NlZENlbGxzID09IG1pbmVzICYmIGFycmF5W2ldW2pdLm1pbmUgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGFycmF5W2ldW2pdLm9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgJCgnLnBsYXlBZ2FpbicpLmF0dHIoJ2NsYXNzJywgJ3VzZXJXb24nKVxuICAgICAgICAgICAgYXJyYXkuZm9yRWFjaChyID0+IHIuZm9yRWFjaChjZWxsID0+IGNlbGwub3BlbiA9IHRydWUpKTtcbiAgICAgICAgICAgIHJlbmRlcigpO1xuICAgICAgICAgICAgQXNrRm9ySGlnaFNjb3JlU3VibWl0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBTZXRTaXplKHcsIGgpIHtcbiAgICB3aWR0aCA9IHBhcnNlSW50KHcpO1xuICAgIGhlaWdodCA9IHBhcnNlSW50KGgpO1xuICAgIHZhciBtaW5lcyA9IE1hdGgucm91bmQoKHdpZHRoICogaGVpZ2h0KSAvIDgpICsgMTtcbiAgICAkKCcjc2l6ZScpLnRvZ2dsZSgpO1xuICAgICQoJyNnYW1lJykudG9nZ2xlKCk7XG4gICAgUmVzZXRIaWdoU2NvcmUoKVxuICAgIFN0YXJ0R2FtZSgpO1xufVxuXG5mdW5jdGlvbiBTZXRDdXN0b21TaXplKHcsIGgpe1xuICAgIGhlaWdodCA9ICQoJyNoZWlnaHQnKS52YWwoKTtcbiAgICBoZWlnaHQgPSBwYXJzZUludChoZWlnaHQpO1xuICAgIHdpZHRoID0gJCgnI3dpZHRoJykudmFsKCk7XG4gICAgd2lkdGggPSBwYXJzZUludCh3aWR0aCk7XG4gICAgXG4gICAgaWYoaGVpZ2h0ID49IDIgJiYgd2lkdGggPj0gMiAmJiBoZWlnaHQgPD0gNTAgJiYgd2lkdGggPD0gNTApe1xuICAgICAgICB2YXIgbWluZXMgPSBNYXRoLnJvdW5kKCh3aWR0aCAqIGhlaWdodCkgLyA4KSArIDE7XG4gICAgICAgICQoJyNzaXplJykudG9nZ2xlKCk7XG4gICAgICAgICQoJyNnYW1lJykudG9nZ2xlKCk7XG4gICAgICAgIFJlc2V0SGlnaFNjb3JlKClcbiAgICAgICAgU3RhcnRHYW1lKCk7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgICQoJyNjaG9vc2VTaXplJykuaHRtbCgnPHAgc3R5bGU9XCJjb2xvcjogcmVkO1wiPlRvbyBtYW55IGluZ3JlZGllbnRzPHAvPicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG5mdW5jdGlvbiBBc2tGb3JIaWdoU2NvcmVTdWJtaXQoKSB7XG4gICAgaWYodG9wVGVuU2NvcmUubGVuZ3RoID49IDEwKXtcbiAgICAgICAgaWYodG9wVGVuU2NvcmVbOV0uc2NvcmUgPiB0aW1lckFuZEhpZ2hzY29yZSl7XG4gICAgICAgICAgICAgICAgaWYoY29uZmlybSgnVG9wIHRlbiEgU3VibWl0IGhpZ2hzY29yZT8nKSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gcHJvbXB0KCdDaG9vc2UgbmFtZSAobWF4IDEwIGNoYXJhY3RlcnMpJylcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuYW1lLmxlbmd0aCA8PSAxMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQWRkSGlnaFNjb3JlKHRpbWVyQW5kSGlnaHNjb3JlLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcHJvbXB0KCdNYXggMTAgY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBhbGVydCgnVG9vIGJhZCEnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNle1xuICAgICAgICBpZihjb25maXJtKCdUb3AgdGVuISBTdWJtaXQgaGlnaHNjb3JlPycpKXtcbiAgICAgICAgICAgIHZhciBuYW1lID0gcHJvbXB0KCdDaG9vc2UgbmFtZSAobWF4IDEwIGNoYXJhY3RlcnMpJylcbiAgICAgICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgICAgIGlmKG5hbWUubGVuZ3RoIDw9IDEwKXtcbiAgICAgICAgICAgICAgICAgICAgQWRkSGlnaFNjb3JlKHRpbWVyQW5kSGlnaHNjb3JlLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9tcHQoJ01heCAxMCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBSZXNldCgpIHtcbiAgICBVcGRhdGVDb3VudGVyVGV4dCgpXG4gICAgJCgnI3BsYXlBZ2FpbicpLmF0dHIoJ2NsYXNzJywgJ3BsYXlBZ2FpbicpXG4gICAgdHJ5IHtjbGVhckludGVydmFsKHN0YXJ0VGltZXIpO30gY2F0Y2ggKGVycm9yKSB7fVxuICAgIHRpbWVyQW5kSGlnaHNjb3JlID0gMTtcbiAgICAkKCcjdGltZXInKS50ZXh0KHRpbWVyQW5kSGlnaHNjb3JlKTtcbiAgICBzdGFydFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge3RpbWVyQW5kSGlnaHNjb3JlKys7ICQoJyN0aW1lcicpLnRleHQodGltZXJBbmRIaWdoc2NvcmUpfSwgMTAwMCk7XG4gICAgXG59XG5cbmZ1bmN0aW9uIFJlc2V0SGlnaFNjb3JlKCkge1xuICAgICQoJyNoaWdoU2NvcmVUZXh0JykudGV4dCgnTG93c2NvcmUgJyArIHdpZHRoICsgJyB4ICcgKyBoZWlnaHQpOyAgICBcbiAgICAkKCcjaHNCb2R5JykuZW1wdHkoKTsgICAgXG4gICAgdG9wVGVuU2NvcmUgPSBbXVxuICAgIGRhdGFiYXNlLnJlZignL2hpZ2hzY29yZS8nICsgd2lkdGggKyBoZWlnaHQgKyAnLycpLm9uY2UoJ3ZhbHVlJykudGhlbihmdW5jdGlvbihzbmFwc2hvdCkge1xuICAgICAgICBsZXQgb2JqID0gc25hcHNob3QudmFsKClcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgICAgICAgIHRvcFRlblNjb3JlLnB1c2goe3VzZXJuYW1lOiBvYmpba2V5XS51c2VybmFtZSwgc2NvcmU6IG9ialtrZXldLnNjb3JlfSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9wVGVuU2NvcmUuc29ydCgoYSwgYikgPT4gYS5zY29yZSAtIGIuc2NvcmUpO1xuICAgICAgICB0b3BUZW5TY29yZS5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgdmFyIG5ld1RyID0gJCgnPHRyLz4nKTtcbiAgICAgICAgICAgIG5ld1RyLmFwcGVuZCgkKCc8dGQvPicsIHt0ZXh0OiBjLnVzZXJuYW1lfSkpXG4gICAgICAgICAgICBuZXdUci5hcHBlbmQoJCgnPHRkLz4nLCB7dGV4dDogYy5zY29yZSwgY2xhc3M6ICdzY29yZVRkJ30pKVxuICAgICAgICAgICAgJCgnI2hzQm9keScpLmFwcGVuZChuZXdUcilcbiAgICAgICAgfSlcbiAgICB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);