/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/public/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* no static exports found */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(module, exports) {

eval("var $mineSweeper = $('#myMineSweeper');\nvar mines = 0;\nvar height = 0;\nvar width = 0;\nvar array = [];\nvar flagCounter = 0;\n\nfunction UpdateCounterText() {\n    var nextCounter = array.reduce((p, c) => {\n        let counter = 0;\n        c.forEach(o => o.flag ? counter++ : o);\n        return p - counter;\n    }, mines);\n    $('#counterText').text(nextCounter);\n    flagCounter = nextCounter;\n};\n\nfunction StartGame() {\n    for (var i = 0; i < height; i++) {\n        array[i] = [];\n        for (var j = 0; j < width; j++) {\n            array[i][j] = {\n                number: 0,\n                open: false,\n                mine: false,\n                flag: false,\n                ask: false\n            };\n        }\n    }\n    for (var i = 0; i < mines; i++) {\n        AddRandomMine();\n    }\n\n    function AddRandomMine() {\n        var loop = true;\n        while (loop) {\n            var column = Math.floor(Math.random() * width);\n            var row = Math.floor(Math.random() * height);\n\n            if (!array[row][column].mine) {\n                array[row][column].mine = true;\n                loop = false;\n            }\n        }\n    };\n\n    AddNumbers();\n    function AddNumbers() {\n        for (var i = 0; i < array.length; i++) {\n            for (var j = 0; j < array[i].length; j++) {\n                if (!array[i][j].mine) {\n                    var surroundingCells = GetSurroundingMines(array, i, j);\n                    array[i][j].number = surroundingCells.length;\n                }\n            }\n        }\n    };\n\n    GetSurroundingMines(array, 0, 0);\n    function GetSurroundingMines(array, i, j) {\n        var simonCells = [[i + 1, j], [i + 1, j + 1], [i + 1, j - 1], [i - 1, j], [i - 1, j - 1], [i - 1, j + 1], [i, j + 1], [i, j - 1]];\n\n        var validCells = simonCells.filter(function (cell) {\n            var i = cell[0];\n            var j = cell[1];\n            return i >= 0 && i < array.length && j >= 0 && j < array[0].length;\n        });\n        var realCells = validCells.map(function (cell) {\n            var i = cell[0];\n            var j = cell[1];\n            return array[i][j];\n        });\n        var numberOfMines = realCells.filter(function (array) {\n            return array.mine;\n        });\n\n        return numberOfMines;\n    };\n    //Reset counter and button picture\n    UpdateCounterText();\n    $('#playAgain').attr('class', 'playAgain');\n\n    render();\n    function render() {\n        $mineSweeper.empty();\n        for (var i = 0; i < array.length; i++) {\n            var $myRow = $('<div/>', { class: 'row' });\n            $mineSweeper.append($myRow);\n            for (var j = 0; j < array[i].length; j++) {\n                var selectedCell = array[i][j];\n                var text = selectedCell.mine ? ' ' : selectedCell.number > 0 ? selectedCell.number : ' ';\n                $myRow.append($('<button/>', {\n                    type: 'button', 'data-i': i, 'data-j': j,\n                    text: selectedCell.open ? text : ' ',\n                    class: selectedCell.open && selectedCell.mine ? 'openmineCell' : selectedCell.open ? 'opencell' : selectedCell.flag ? 'flagCell' : selectedCell.ask ? 'askCell' : 'cell'\n                }));\n            }\n        }\n    };\n\n    function OpenSurroundingCells(array, i, j) {\n        var simonCells = [[i + 1, j], [i + 1, j + 1], [i + 1, j - 1], [i - 1, j], [i - 1, j - 1], [i - 1, j + 1], [i, j + 1], [i, j - 1]];\n        var validCells = simonCells.filter(function (cell) {\n            var i = cell[0];\n            var j = cell[1];\n            return i >= 0 && i < array.length && j >= 0 && j < array[0].length;\n        });\n        var cellsForRecursion = validCells.filter(function (cell) {\n            i = cell[0];\n            j = cell[1];\n            return array[i][j].open == false && array[i][j].number == 0;\n        });\n        validCells.forEach(function (cell) {\n            i = cell[0];\n            j = cell[1];\n            array[i][j].open = true;\n            array[i][j].flag = false;\n            array[i][j].ask = false;\n        });\n        return cellsForRecursion;\n    };\n\n    $(document).on('contextmenu', '.flagCell, .cell, .askCell', function (event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        var $cell = $(this);\n\n        const setCellClass = n => $cell.attr('class', n);\n\n        var i = $cell.data('i');\n        var j = $cell.data('j');\n\n        switch ($cell.attr('class')) {\n            case 'cell':\n                if (flagCounter >= 1) {\n                    array[i][j].flag = true;\n                    setCellClass('flagCell');\n                    break;\n                } else {\n                    return;\n                }\n            case 'flagCell':\n                array[i][j].flag = false;\n                array[i][j].ask = true;\n                setCellClass('askCell');\n                break;\n            case 'askCell':\n                array[i][j].ask = false;\n                setCellClass('cell');\n                break;\n        };\n        UpdateCounterText();\n    });\n\n    $(document).on('click', '.cell', function (event) {\n        event.stopImmediatePropagation();\n        var $cell = $(this);\n        var i = $cell.data('i');\n        var j = $cell.data('j');\n\n        var closedCells = array.reduce((p, c) => {\n            let numberOfClosedCells = 0;\n            c.forEach(o => o.open ? o : numberOfClosedCells++);\n            return p + numberOfClosedCells;\n        }, 0);\n\n        if (closedCells == mines + 1 && array[i][j].mine == false) {\n            array[i][j].open = true;\n            render();\n            $('.playAgain').toggleClass('userWon');\n            array.forEach(r => r.forEach(cell => cell.open = true));\n        } else if (array[i][j].number != 0) {\n            array[i][j].open = true;\n        } else if (array[i][j].number == 0 && !array[i][j].mine) {\n            array[i][j].open = true;\n            var allCellsToCheck = OpenSurroundingCells(array, i, j);\n            var loopingLength = allCellsToCheck;\n            for (var k = 0; k < loopingLength.length; k++) {\n                i = allCellsToCheck[k][0];\n                j = allCellsToCheck[k][1];\n                var returnedCells = OpenSurroundingCells(array, i, j);\n                if (returnedCells.length > 0) {\n                    for (var l = 0; l < returnedCells.length; l++) {\n                        loopingLength.push(returnedCells[l]);\n                    }\n                }\n            }\n        } else if (array[i][j].mine) {\n            array.forEach(r => r.forEach(cell => cell.open = true));\n            $('.playAgain').toggleClass('userLost');\n        };\n        UpdateCounterText();\n        render();\n    });\n}\n\nfunction SetUpGame() {\n    height = $('#height').val();\n    height = parseInt(height);\n    width = $('#width').val();\n    width = parseInt(width);\n    if (height >= 2 && width >= 2 && height <= 50 && width <= 50) {\n        mines = Math.round(width * height / 8) + 1;\n        $('#size').toggle();\n        $('#game').toggle();\n        StartGame();\n    } else {\n        $('#chooseSize').html('<p style=\"color: red;\">Must be between 2 and 50<p/>');\n        return;\n    }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJG1pbmVTd2VlcGVyID0gJCgnI215TWluZVN3ZWVwZXInKTtcbnZhciBtaW5lcyA9IDA7XG52YXIgaGVpZ2h0ID0gMDtcbnZhciB3aWR0aCA9IDA7XG52YXIgYXJyYXkgPSBbXTtcbnZhciBmbGFnQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIFVwZGF0ZUNvdW50ZXJUZXh0KCl7XG4gICAgdmFyIG5leHRDb3VudGVyID0gYXJyYXkucmVkdWNlKChwLCBjKSA9PiB7XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgYy5mb3JFYWNoKG8gPT4gby5mbGFnID8gY291bnRlcisrIDogbyk7XG4gICAgICAgIHJldHVybiBwIC0gY291bnRlcjtcbiAgICB9LCBtaW5lcyk7XG4gICAgJCgnI2NvdW50ZXJUZXh0JykudGV4dChuZXh0Q291bnRlcilcbiAgICBmbGFnQ291bnRlciA9IG5leHRDb3VudGVyO1xufTtcblxuXG5mdW5jdGlvbiBTdGFydEdhbWUoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgICAgIGFycmF5W2ldW2pdID0ge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMCxcbiAgICAgICAgICAgICAgICBvcGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtaW5lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmbGFnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc2s6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluZXM7IGkrKykge1xuICAgICAgICBBZGRSYW5kb21NaW5lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQWRkUmFuZG9tTWluZSgpIHtcbiAgICAgICAgdmFyIGxvb3AgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobG9vcCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHdpZHRoKVxuICAgICAgICAgICAgdmFyIHJvdyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGhlaWdodClcblxuICAgICAgICAgICAgaWYgKCFhcnJheVtyb3ddW2NvbHVtbl0ubWluZSkge1xuICAgICAgICAgICAgICAgIGFycmF5W3Jvd11bY29sdW1uXS5taW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQWRkTnVtYmVycygpO1xuICAgIGZ1bmN0aW9uIEFkZE51bWJlcnMoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyYXlbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycmF5W2ldW2pdLm1pbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1cnJvdW5kaW5nQ2VsbHMgPSBHZXRTdXJyb3VuZGluZ01pbmVzKGFycmF5LCBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbaV1bal0ubnVtYmVyID0gc3Vycm91bmRpbmdDZWxscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEdldFN1cnJvdW5kaW5nTWluZXMoYXJyYXksIDAsIDApO1xuICAgIGZ1bmN0aW9uIEdldFN1cnJvdW5kaW5nTWluZXMoYXJyYXksIGksIGopIHtcbiAgICAgICAgdmFyIHNpbW9uQ2VsbHMgPSBbW2kgKyAxLCBqXSwgW2kgKyAxLCBqICsgMV0sIFtpICsgMSwgaiAtIDFdLCBbaSAtIDEsIGpdLCBbaSAtIDEsIGogLSAxXSwgW2kgLSAxLCBqICsgMV0sIFtpLCBqICsgMV0sIFtpLCBqIC0gMV1dO1xuXG4gICAgICAgIHZhciB2YWxpZENlbGxzID0gc2ltb25DZWxscy5maWx0ZXIoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgIHZhciBpID0gY2VsbFswXVxuICAgICAgICAgICAgdmFyIGogPSBjZWxsWzFdXG4gICAgICAgICAgICByZXR1cm4gaSA+PSAwICYmIGkgPCBhcnJheS5sZW5ndGggJiYgaiA+PSAwICYmIGogPCBhcnJheVswXS5sZW5ndGhcbiAgICAgICAgfSlcbiAgICAgICAgdmFyIHJlYWxDZWxscyA9IHZhbGlkQ2VsbHMubWFwKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGNlbGxbMF1cbiAgICAgICAgICAgIHZhciBqID0gY2VsbFsxXVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5W2ldW2pdXG4gICAgICAgIH0pXG4gICAgICAgIHZhciBudW1iZXJPZk1pbmVzID0gcmVhbENlbGxzLmZpbHRlcihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5taW5lO1xuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBudW1iZXJPZk1pbmVzO1xuICAgIH07XG4gICAgLy9SZXNldCBjb3VudGVyIGFuZCBidXR0b24gcGljdHVyZVxuICAgIFVwZGF0ZUNvdW50ZXJUZXh0KClcbiAgICAkKCcjcGxheUFnYWluJykuYXR0cignY2xhc3MnLCAncGxheUFnYWluJylcblxuICAgIHJlbmRlcigpO1xuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgJG1pbmVTd2VlcGVyLmVtcHR5KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAkbXlSb3cgPSAkKCc8ZGl2Lz4nLCB7IGNsYXNzOiAncm93JyB9KVxuICAgICAgICAgICAgJG1pbmVTd2VlcGVyLmFwcGVuZCgkbXlSb3cpXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkQ2VsbCA9IGFycmF5W2ldW2pdXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzZWxlY3RlZENlbGwubWluZSA/ICcgJyA6IHNlbGVjdGVkQ2VsbC5udW1iZXIgPiAwID8gc2VsZWN0ZWRDZWxsLm51bWJlciA6ICcgJztcbiAgICAgICAgICAgICAgICAkbXlSb3cuYXBwZW5kKCQoJzxidXR0b24vPicsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2J1dHRvbicsICdkYXRhLWknOiBpLCAnZGF0YS1qJzogaixcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogc2VsZWN0ZWRDZWxsLm9wZW4gPyB0ZXh0IDogJyAnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczogc2VsZWN0ZWRDZWxsLm9wZW4gJiYgc2VsZWN0ZWRDZWxsLm1pbmUgPyAnb3Blbm1pbmVDZWxsJyA6IHNlbGVjdGVkQ2VsbC5vcGVuID8gJ29wZW5jZWxsJyA6IHNlbGVjdGVkQ2VsbC5mbGFnID8gJ2ZsYWdDZWxsJyA6IHNlbGVjdGVkQ2VsbC5hc2sgPyAnYXNrQ2VsbCcgOiAnY2VsbCdcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBPcGVuU3Vycm91bmRpbmdDZWxscyhhcnJheSwgaSwgaikge1xuICAgICAgICB2YXIgc2ltb25DZWxscyA9IFtbaSArIDEsIGpdLCBbaSArIDEsIGogKyAxXSwgW2kgKyAxLCBqIC0gMV0sIFtpIC0gMSwgal0sIFtpIC0gMSwgaiAtIDFdLCBbaSAtIDEsIGogKyAxXSwgW2ksIGogKyAxXSwgW2ksIGogLSAxXV07XG4gICAgICAgIHZhciB2YWxpZENlbGxzID0gc2ltb25DZWxscy5maWx0ZXIoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgIHZhciBpID0gY2VsbFswXVxuICAgICAgICAgICAgdmFyIGogPSBjZWxsWzFdXG4gICAgICAgICAgICByZXR1cm4gaSA+PSAwICYmIGkgPCBhcnJheS5sZW5ndGggJiYgaiA+PSAwICYmIGogPCBhcnJheVswXS5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjZWxsc0ZvclJlY3Vyc2lvbiA9IHZhbGlkQ2VsbHMuZmlsdGVyKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICBpID0gY2VsbFswXVxuICAgICAgICAgICAgaiA9IGNlbGxbMV1cbiAgICAgICAgICAgIHJldHVybiBhcnJheVtpXVtqXS5vcGVuID09IGZhbHNlICYmIGFycmF5W2ldW2pdLm51bWJlciA9PSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFsaWRDZWxscy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICBpID0gY2VsbFswXVxuICAgICAgICAgICAgaiA9IGNlbGxbMV1cbiAgICAgICAgICAgIGFycmF5W2ldW2pdLm9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgYXJyYXlbaV1bal0uZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgYXJyYXlbaV1bal0uYXNrID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2VsbHNGb3JSZWN1cnNpb247XG4gICAgfTtcblxuICAgICQoZG9jdW1lbnQpLm9uKCdjb250ZXh0bWVudScsICcuZmxhZ0NlbGwsIC5jZWxsLCAuYXNrQ2VsbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdmFyICRjZWxsID0gJCh0aGlzKTsgIFxuXG4gICAgICAgIGNvbnN0IHNldENlbGxDbGFzcyA9IChuKSA9PiAkY2VsbC5hdHRyKCdjbGFzcycsIG4pO1xuXG4gICAgICAgIHZhciBpID0gJGNlbGwuZGF0YSgnaScpO1xuICAgICAgICB2YXIgaiA9ICRjZWxsLmRhdGEoJ2onKTtcbiAgICAgICAgXG4gICAgICAgIHN3aXRjaCgkY2VsbC5hdHRyKCdjbGFzcycpKXtcbiAgICAgICAgICAgIGNhc2UgJ2NlbGwnOlxuICAgICAgICAgICAgICAgIGlmKGZsYWdDb3VudGVyID49IDEpe1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtpXVtqXS5mbGFnID0gdHJ1ZTsgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHNldENlbGxDbGFzcygnZmxhZ0NlbGwnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdmbGFnQ2VsbCc6XG4gICAgICAgICAgICAgICAgYXJyYXlbaV1bal0uZmxhZyA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGFycmF5W2ldW2pdLmFzayA9IHRydWU7ICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNldENlbGxDbGFzcygnYXNrQ2VsbCcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhc2tDZWxsJzpcbiAgICAgICAgICAgICAgICBhcnJheVtpXVtqXS5hc2sgPSBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNldENlbGxDbGFzcygnY2VsbCcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH07XG4gICAgICAgIFVwZGF0ZUNvdW50ZXJUZXh0KCk7ICAgICAgICAgIFxuICAgIH0pXG5cbiAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnLmNlbGwnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciAkY2VsbCA9ICQodGhpcylcbiAgICAgICAgdmFyIGkgPSAkY2VsbC5kYXRhKCdpJyk7XG4gICAgICAgIHZhciBqID0gJGNlbGwuZGF0YSgnaicpO1xuXG5cbiAgICAgICAgdmFyIGNsb3NlZENlbGxzID0gYXJyYXkucmVkdWNlKChwLCBjKSA9PiB7XG4gICAgICAgICAgICBsZXQgbnVtYmVyT2ZDbG9zZWRDZWxscyA9IDA7XG4gICAgICAgICAgICBjLmZvckVhY2gobyA9PiBvLm9wZW4gPyBvIDogbnVtYmVyT2ZDbG9zZWRDZWxscysrKTtcbiAgICAgICAgICAgIHJldHVybiBwICsgbnVtYmVyT2ZDbG9zZWRDZWxscztcbiAgICAgICAgfSwgMCk7XG4gICAgICBcbiAgICAgICAgaWYgKGNsb3NlZENlbGxzID09IG1pbmVzICsgMSAmJiBhcnJheVtpXVtqXS5taW5lID09IGZhbHNlKSB7XG4gICAgICAgICAgICBhcnJheVtpXVtqXS5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlbmRlcigpO1xuICAgICAgICAgICAgJCgnLnBsYXlBZ2FpbicpLnRvZ2dsZUNsYXNzKCd1c2VyV29uJylcbiAgICAgICAgICAgIGFycmF5LmZvckVhY2gociA9PiByLmZvckVhY2goY2VsbCA9PiBjZWxsLm9wZW4gPSB0cnVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChhcnJheVtpXVtqXS5udW1iZXIgIT0gMCkge1xuICAgICAgICAgICAgYXJyYXlbaV1bal0ub3BlbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChhcnJheVtpXVtqXS5udW1iZXIgPT0gMCAmJiAhYXJyYXlbaV1bal0ubWluZSkge1xuICAgICAgICAgICAgYXJyYXlbaV1bal0ub3BlbiA9IHRydWU7XG4gICAgICAgICAgICB2YXIgYWxsQ2VsbHNUb0NoZWNrID0gT3BlblN1cnJvdW5kaW5nQ2VsbHMoYXJyYXksIGksIGopO1xuICAgICAgICAgICAgdmFyIGxvb3BpbmdMZW5ndGggPSBhbGxDZWxsc1RvQ2hlY2s7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxvb3BpbmdMZW5ndGgubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpID0gYWxsQ2VsbHNUb0NoZWNrW2tdWzBdO1xuICAgICAgICAgICAgICAgIGogPSBhbGxDZWxsc1RvQ2hlY2tba11bMV07XG4gICAgICAgICAgICAgICAgdmFyIHJldHVybmVkQ2VsbHMgPSBPcGVuU3Vycm91bmRpbmdDZWxscyhhcnJheSwgaSwgaik7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkQ2VsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHJldHVybmVkQ2VsbHMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb3BpbmdMZW5ndGgucHVzaChyZXR1cm5lZENlbGxzW2xdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKGFycmF5W2ldW2pdLm1pbmUpIHtcbiAgICAgICAgICAgIGFycmF5LmZvckVhY2gociA9PiByLmZvckVhY2goY2VsbCA9PiBjZWxsLm9wZW4gPSB0cnVlKSk7XG4gICAgICAgICAgICAkKCcucGxheUFnYWluJykudG9nZ2xlQ2xhc3MoJ3VzZXJMb3N0JylcbiAgICAgICAgfTtcbiAgICAgICAgVXBkYXRlQ291bnRlclRleHQoKTtcbiAgICAgICAgcmVuZGVyKCk7XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gU2V0VXBHYW1lKCl7XG4gICAgaGVpZ2h0ID0gJCgnI2hlaWdodCcpLnZhbCgpO1xuICAgIGhlaWdodCA9IHBhcnNlSW50KGhlaWdodCk7XG4gICAgd2lkdGggPSAkKCcjd2lkdGgnKS52YWwoKTtcbiAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoKTtcbiAgICBpZihoZWlnaHQgPj0gMiAmJiB3aWR0aCA+PSAyICYmIGhlaWdodCA8PSA1MCAmJiB3aWR0aCA8PSA1MCl7XG4gICAgICAgIG1pbmVzID0gTWF0aC5yb3VuZCgod2lkdGggKiBoZWlnaHQpIC8gOCkgKyAxO1xuICAgICAgICAkKCcjc2l6ZScpLnRvZ2dsZSgpO1xuICAgICAgICAkKCcjZ2FtZScpLnRvZ2dsZSgpO1xuICAgICAgICBTdGFydEdhbWUoKTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgJCgnI2Nob29zZVNpemUnKS5odG1sKCc8cCBzdHlsZT1cImNvbG9yOiByZWQ7XCI+TXVzdCBiZSBiZXR3ZWVuIDIgYW5kIDUwPHAvPicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbmRleC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);